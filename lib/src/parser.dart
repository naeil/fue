// This code was generated by a tool.
// Processing tool available at https://github.com/mezoni/peg

part of fue;

class Parser {
  static final List<String> _ascii = new List<String>.generate(128, (c) => new String.fromCharCode(c));
  
  static final List<String> _expect0 = <String>[",", "WS"];
  
  static final List<String> _expect1 = <String>[","];
  
  static final List<String> _expect10 = <String>["UnaryOperator"];
  
  static final List<String> _expect11 = <String>["MultiplicativeOperator", "WS"];
  
  static final List<String> _expect12 = <String>["MultiplicativeOperator"];
  
  static final List<String> _expect13 = <String>["AdditiveOperator", "WS"];
  
  static final List<String> _expect14 = <String>["AdditiveOperator"];
  
  static final List<String> _expect15 = <String>["ShiftOperator", "WS"];
  
  static final List<String> _expect16 = <String>["ShiftOperator"];
  
  static final List<String> _expect17 = <String>["RelationalOperator", "WS"];
  
  static final List<String> _expect18 = <String>["RelationalOperator"];
  
  static final List<String> _expect19 = <String>["RelationalOperatorNoIn"];
  
  static final List<String> _expect2 = <String>[".", "WS", "["];
  
  static final List<String> _expect20 = <String>["EqualityOperator", "WS"];
  
  static final List<String> _expect21 = <String>["EqualityOperator"];
  
  static final List<String> _expect22 = <String>["\'&\'", "WS"];
  
  static final List<String> _expect23 = <String>["\'&\'"];
  
  static final List<String> _expect24 = <String>["\'^\'", "WS"];
  
  static final List<String> _expect25 = <String>["\'^\'"];
  
  static final List<String> _expect26 = <String>["\'|\'", "WS"];
  
  static final List<String> _expect27 = <String>["\'|\'"];
  
  static final List<String> _expect28 = <String>["\'&&\'", "WS"];
  
  static final List<String> _expect29 = <String>["\'&&\'"];
  
  static final List<String> _expect3 = <String>["(", ".", "WS", "["];
  
  static final List<String> _expect30 = <String>["\'||\'", "WS"];
  
  static final List<String> _expect31 = <String>["\'||\'"];
  
  static final List<String> _expect32 = <String>["AssignmentOperator"];
  
  static final List<String> _expect33 = <String>["StringLiteral"];
  
  static final List<String> _expect34 = <String>["\\"];
  
  static final List<String> _expect35 = <String>["\"", "\'", "\\", "b", "f", "n", "r", "t", "v"];
  
  static final List<String> _expect36 = <String>["x"];
  
  static final List<String> _expect37 = <String>["u"];
  
  static final List<String> _expect38 = <String>["\\n", "\\r", "\\r\\n", "\u2028", "\u2029"];
  
  static final List<String> _expect39 = <String>["WS"];
  
  static final List<String> _expect4 = <String>["("];
  
  static final List<String> _expect40 = <String>["EOF"];
  
  static final List<String> _expect41 = <String>["BS"];
  
  static final List<String> _expect42 = <String>["{"];
  
  static final List<String> _expect43 = <String>["["];
  
  static final List<String> _expect5 = <String>[];
  
  static final List<String> _expect6 = <String>["ReservedWord"];
  
  static final List<String> _expect7 = <String>["\'null\'"];
  
  static final List<String> _expect8 = <String>["BooleanLiteral"];
  
  static final List<String> _expect9 = <String>["PostfixOperator"];
  
  static final List<bool> _lookahead = _unmap([0x1401, 0x0, 0x0, 0x1ff804b, 0x7fffffe, 0x3ffffffd, 0x5000ac, 0x800000, 0x10c00000, 0xffc0, 0x22080000, 0x37440, 0x7fff8000, 0x7fff43ff, 0x10fff, 0x0, 0x22022080, 0x7fe010d, 0x0, 0x7f820200, 0x7, 0x3f800, 0x6000c000, 0x210]);
  
  static final List<bool> _mapping0 = _unmap([0x60000001, 0x50ffffff, 0x1ffffff]);
  
  static final List<bool> _mapping1 = _unmap([0x603ff001, 0x50ffffff, 0x1ffffff]);
  
  static final List<bool> _mapping2 = _unmap([0x40001]);
  
  static final List<bool> _mapping3 = _unmap([0x10001]);
  
  static final List<bool> _mapping4 = _unmap([0x800001]);
  
  static final List<bool> _mapping5 = _unmap([0x1, 0x0, 0x2]);
  
  static final List<bool> _mapping6 = _unmap([0x3ff, 0xfc0000]);
  
  static final List<bool> _mapping7 = _unmap([0x9]);
  
  static final List<bool> _mapping8 = _unmap([0x800013]);
  
  static final List<int> _ranges0 = <int>[8232, 8233];
  
  static final List<int> _strings0 = <int>[61, 62];
  
  static final List<int> _strings1 = <int>[105, 110];
  
  static final List<int> _strings10 = <int>[60, 60];
  
  static final List<int> _strings11 = <int>[62, 62, 62];
  
  static final List<int> _strings12 = <int>[62, 62];
  
  static final List<int> _strings13 = <int>[60, 61];
  
  static final List<int> _strings14 = <int>[62, 61];
  
  static final List<int> _strings15 = <int>[33, 61, 61];
  
  static final List<int> _strings16 = <int>[33, 61];
  
  static final List<int> _strings17 = <int>[61, 61, 61];
  
  static final List<int> _strings18 = <int>[61, 61];
  
  static final List<int> _strings19 = <int>[38, 38];
  
  static final List<int> _strings2 = <int>[123, 123];
  
  static final List<int> _strings20 = <int>[124, 124];
  
  static final List<int> _strings21 = <int>[37, 61];
  
  static final List<int> _strings22 = <int>[38, 61];
  
  static final List<int> _strings23 = <int>[42, 61];
  
  static final List<int> _strings24 = <int>[43, 61];
  
  static final List<int> _strings25 = <int>[45, 61];
  
  static final List<int> _strings26 = <int>[47, 61];
  
  static final List<int> _strings27 = <int>[60, 60, 61];
  
  static final List<int> _strings28 = <int>[62, 62, 61];
  
  static final List<int> _strings29 = <int>[62, 62, 62, 61];
  
  static final List<int> _strings3 = <int>[125, 125];
  
  static final List<int> _strings30 = <int>[94, 61];
  
  static final List<int> _strings31 = <int>[124, 61];
  
  static final List<int> _strings32 = <int>[13, 10];
  
  static final List<int> _strings4 = <int>[116, 104, 105, 115];
  
  static final List<int> _strings5 = <int>[102, 97, 108, 115, 101];
  
  static final List<int> _strings6 = <int>[110, 117, 108, 108];
  
  static final List<int> _strings7 = <int>[116, 114, 117, 101];
  
  static final List<int> _strings8 = <int>[43, 43];
  
  static final List<int> _strings9 = <int>[45, 45];
  
  final List<String> _tokenAliases = ["ReservedWord", "\'null\'", "BooleanLiteral", "PostfixOperator", "UnaryOperator", "MultiplicativeOperator", "AdditiveOperator", "ShiftOperator", "RelationalOperator", "RelationalOperatorNoIn", "EqualityOperator", "\'&\'", "\'^\'", "\'|\'", "\'&&\'", "\'||\'", "AssignmentOperator", "StringLiteral", "WS", "EOF", "BS"];
  
  final List<int> _tokenFlags = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1];
  
  final List<String> _tokenNames = ["ReservedWord", "NullLiteral", "BooleanLiteral", "PostfixOperator", "UnaryOperator", "MultiplicativeOperator", "AdditiveOperator", "ShiftOperator", "RelationalOperator", "RelationalOperatorNoIn", "EqualityOperator", "BitwiseANDOperator", "BitwiseXOROperator", "BitwiseOROperator", "LogicalANDOperator", "LogicalOROperator", "AssignmentOperator", "StringLiteral", "WS", "EOF", "BS"];
  
  static final List<List<int>> _transitions0 = [[0, 115], [116, 116], [117, 1114111]];
  
  static final List<List<int>> _transitions1 = [[102, 102], [110, 110], [116, 116]];
  
  static final List<List<int>> _transitions10 = [[33, 33], [61, 61]];
  
  static final List<List<int>> _transitions11 = [[37, 37], [38, 38], [42, 42], [43, 43], [45, 45], [47, 47], [60, 60], [62, 62], [94, 94], [124, 124]];
  
  static final List<List<int>> _transitions12 = [[34, 34], [39, 39]];
  
  static final List<List<int>> _transitions13 = [[10, 10, 13, 13, 8232, 8233], [34, 34], [92, 92]];
  
  static final List<List<int>> _transitions14 = [[10, 10, 13, 13, 8232, 8233], [39, 39], [92, 92]];
  
  static final List<List<int>> _transitions15 = [[0, 33, 35, 38, 40, 91, 93, 97, 99, 101, 103, 109, 111, 113, 115, 115, 117, 117, 119, 1114111], [34, 34, 39, 39, 92, 92, 98, 98, 102, 102, 110, 110, 114, 114, 116, 116, 118, 118]];
  
  static final List<List<int>> _transitions16 = [[34, 34], [39, 39], [92, 92], [98, 98], [102, 102], [110, 110], [114, 114], [116, 116], [118, 118]];
  
  static final List<List<int>> _transitions17 = [[10, 10, 13, 13, 8232, 8233], [34, 34, 39, 39, 48, 57, 92, 92, 98, 98, 102, 102, 110, 110, 114, 114, 116, 118, 120, 120]];
  
  static final List<List<int>> _transitions18 = [[34, 34, 39, 39, 92, 92, 98, 98, 102, 102, 110, 110, 114, 114, 116, 116, 118, 118], [48, 57], [117, 117], [120, 120]];
  
  static final List<List<int>> _transitions19 = [[48, 57, 97, 102]];
  
  static final List<List<int>> _transitions2 = [[36, 36, 65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions20 = [[10, 10, 13, 13, 8232, 8233]];
  
  static final List<List<int>> _transitions21 = [[10, 10], [13, 13], [8232, 8232], [8233, 8233]];
  
  static final List<List<int>> _transitions22 = [[48, 48], [49, 57]];
  
  static final List<List<int>> _transitions23 = [[9, 10, 32, 32], [13, 13]];
  
  static final List<List<int>> _transitions24 = [[34, 34, 36, 36, 39, 39, 48, 57, 65, 90, 95, 95, 97, 122]];
  
  static final List<List<int>> _transitions25 = [[34, 34, 39, 39], [36, 36, 65, 90, 95, 95, 97, 122], [48, 57]];
  
  static final List<List<int>> _transitions3 = [[34, 34, 39, 39], [48, 57], [102, 102, 116, 116], [110, 110]];
  
  static final List<List<int>> _transitions4 = [[102, 102], [116, 116]];
  
  static final List<List<int>> _transitions5 = [[43, 43], [45, 45]];
  
  static final List<List<int>> _transitions6 = [[33, 33], [43, 43], [45, 45], [126, 126]];
  
  static final List<List<int>> _transitions7 = [[37, 37], [42, 42], [47, 47]];
  
  static final List<List<int>> _transitions8 = [[60, 60], [62, 62]];
  
  static final List<List<int>> _transitions9 = [];
  
  List<Map<int, List>> _cache;
  
  List<int> _cachePos;
  
  List<bool> _cacheable;
  
  int _ch;
  
  int _cursor;
  
  List<ParserError> _errors;
  
  List<String> _expected;
  
  int _failurePos;
  
  List<int> _input;
  
  int _inputLen;
  
  int _startPos;
  
  int _testing;
  
  int _token;
  
  int _tokenStart;
  
  bool success;
  
  final String text;
  
  Parser(this.text) {
    if (text == null) {
      throw new ArgumentError('text: $text');
    }    
    _input = _toCodePoints(text);
    _inputLen = _input.length;    
    reset(0);    
  }
  
  void _addToCache(dynamic result, int start, int id) {   
    var map = _cache[id];
    if (map == null) {
      map = <int, List>{};
      _cache[id] = map;
    }
    map[start] = [result, _cursor, success];      
  }
  
  void _failure([List<String> expected]) {  
    if (_failurePos > _cursor) {
      return;
    }
    if (_failurePos < _cursor) {    
      _expected = [];
     _failurePos = _cursor;
    }
    if (_token != null) {
      var alias = _tokenAliases[_token];
      var flag = _tokenFlags[_token];
      var name = _tokenNames[_token];
      if (_failurePos > _tokenStart && _failurePos == _inputLen && (flag & 1) != 0) {             
        var message = "Unterminated '$name'";
        _errors.add(new ParserError(ParserError.UNTERMINATED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else if (_failurePos > _tokenStart && (flag & 1) != 0) {             
        var message = "Malformed '$name'";
        _errors.add(new ParserError(ParserError.MALFORMED, _failurePos, _tokenStart, message));
        _expected.addAll(expected);            
      } else {
        _expected.add(alias);
      }            
    } else if (expected == null) {
      _expected.add(null);
    } else {
      _expected.addAll(expected);
    }   
  }
  
  List _flatten(dynamic value) {
    if (value is List) {
      var result = [];
      var length = value.length;
      for (var i = 0; i < length; i++) {
        var element = value[i];
        if (element is Iterable) {
          result.addAll(_flatten(element));
        } else {
          result.add(element);
        }
      }
      return result;
    } else if (value is Iterable) {
      var result = [];
      for (var element in value) {
        if (element is! List) {
          result.add(element);
        } else {
          result.addAll(_flatten(element));
        }
      }
    }
    return [value];
  }
  
  dynamic _getFromCache(int id) {  
    if (!_cacheable[id]) {  
      _cacheable[id] = true;  
      return null;
    }
    var map = _cache[id];
    if (map == null) {
      return null;
    }
    var data = map[_cursor];
    if (data == null) {
      return null;
    }
    _cursor = data[1];
    success = data[2];
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }
    return data;  
  }
  
  int _getState(List<List<int>> transitions) {
    var count = transitions.length;
    var state = 0;
    for ( ; state < count; state++) {
      var found = false;
      var ranges = transitions[state];    
      while (true) {
        var right = ranges.length ~/ 2;
        if (right == 0) {
          break;
        }
        var left = 0;
        if (right == 1) {
          if (_ch <= ranges[1] && _ch >= ranges[0]) {
            found = true;          
          }
          break;
        }
        int middle;
        while (left < right) {
          middle = (left + right) >> 1;
          var index = middle << 1;
          if (ranges[index + 1] < _ch) {
            left = middle + 1;
          } else {
            if (_ch >= ranges[index]) {
              found = true;
              break;
            }
            right = middle;
          }
        }
        break;
      }
      if (found) {
        return state; 
      }   
    }
    if (_ch != -1) {
      return state;
    }
    return state + 1;  
  }
  
  List _list(Object first, List next) {
    var length = next.length;
    var list = new List(length + 1);
    list[0] = first;
    for (var i = 0; i < length; i++) {
      list[i + 1] = next[i][1];
    }
    return list;
  }
  
  String _matchAny() {
    success = _cursor < _inputLen;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }    
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }    
    return null;  
  }
  
  String _matchChar(int ch, String string) {
    success = _ch == ch;
    if (success) {
      var result = string;  
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return result;
    }  
    return null;  
  }
  
  String _matchMapping(int start, int end, List<bool> mapping) {
    success = _ch >= start && _ch <= end;
    if (success) {    
      if(mapping[_ch - start]) {
        String result;
        if (_ch < 128) {
          result = _ascii[_ch];  
        } else {
          result = new String.fromCharCode(_ch);
        }     
        if (++_cursor < _inputLen) {
          _ch = _input[_cursor];
        } else {
          _ch = -1;
        }      
        return result;
      }
      success = false;
    }  
    return null;  
  }
  
  String _matchRange(int start, int end) {
    success = _ch >= start && _ch <= end;
    if (success) {
      String result;
      if (_ch < 128) {
        result = _ascii[_ch];  
      } else {
        result = new String.fromCharCode(_ch);
      }        
      if (++_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }  
      return result;
    }  
    return null;  
  }
  
  String _matchRanges(List<int> ranges) {
    var length = ranges.length;
    for (var i = 0; i < length; i += 2) {    
      if (_ch >= ranges[i]) {
        if (_ch <= ranges[i + 1]) {
          String result;
          if (_ch < 128) {
            result = _ascii[_ch];  
          } else {
            result = new String.fromCharCode(_ch);
          }          
          if (++_cursor < _inputLen) {
            _ch = _input[_cursor];
          } else {
             _ch = -1;
          }
          success = true;    
          return result;
        }      
      } else break;  
    }
    success = false;  
    return null;  
  }
  
  String _matchString(List<int> codePoints, String string) {
    var length = codePoints.length;  
    success = _cursor + length <= _inputLen;
    if (success) {
      for (var i = 0; i < length; i++) {
        if (codePoints[i] != _input[_cursor + i]) {
          success = false;
          break;
        }
      }
    } else {
      success = false;
    }  
    if (success) {
      _cursor += length;      
      if (_cursor < _inputLen) {
        _ch = _input[_cursor];
      } else {
        _ch = -1;
      }    
      return string;      
    }  
    return null; 
  }
  
  void _nextChar() {
    if (++_cursor < _inputLen) {
      _ch = _input[_cursor];
    } else {
      _ch = -1;
    }  
  }
  
  dynamic _parse_AdditiveExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[30] >= pos) {
      $$ = _getFromCache(30);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[30] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_MultiplicativeExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_AdditiveOperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_MultiplicativeExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect13);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[30]) {
      _addToCache($$, pos, 30);
    }    
    return $$;
  }
  
  dynamic _parse_AdditiveOperator() {
    var $$;
    _token = 6;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions5)) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(43, '+');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchMapping(43, 61, _mapping2);
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = BinaryOperator.Plus;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        var ch2 = _ch, pos2 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(45, '-');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchMapping(45, 61, _mapping3);
          _ch = ch3;
          _cursor = pos3; 
          _testing = testing1;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos1;
            $$ = BinaryOperator.Minus;
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos1;
        break;
      case 2:
        $$ = null;
        success = false;
        break;
      case 3:
        while (true) {
          var ch4 = _ch, pos4 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(43, '+');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch5 = _ch, pos5 = _cursor, testing2 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchMapping(43, 61, _mapping2);
            _ch = ch5;
            _cursor = pos5; 
            _testing = testing2;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos2;
              $$ = BinaryOperator.Plus;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos2;
          if (success) break;
          var ch6 = _ch, pos6 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(45, '-');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch7 = _ch, pos7 = _cursor, testing3 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchMapping(45, 61, _mapping3);
            _ch = ch7;
            _cursor = pos7; 
            _testing = testing3;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos3;
              $$ = BinaryOperator.Minus;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos3;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect14);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ArgumentList() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_AssignmentExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _matchChar(44, ',');
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_AssignmentExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  if (success) {    
                    final $1 = seq[0];
                    final $2 = seq[1];
                    final $3 = seq[2];
                    final $4 = seq[3];
                    final $start = startPos1;
                    $$ = $4;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect0);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = [$1]..addAll($2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_Arguments() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[8] >= pos) {
      $$ = _getFromCache(8);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[8] = pos;
    }  
    switch (_ch == 40 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(40, '(');
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          $$ = _parse___();
          if (!success) break;
          seq[1] = $$;
          var testing0 = _testing;
          _testing = _cursor;
          switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
            case 0:
            case 2:
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                $$ = _parse_ArgumentList();
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                $$ = _parse___();
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                if (success) {    
                  final $1 = seq[0];
                  final $2 = seq[1];
                  final $start = startPos1;
                  $$ = $1;
                }
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              break;
            case 1:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            _failure(const [null]);
          }
          success = true; 
          _testing = testing0;
          if (!success) break;
          seq[2] = $$;
          $$ = _matchChar(41, ')');
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $start = startPos0;
            $$ = $3;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect4);
    }
    if (_cacheable[8]) {
      _addToCache($$, pos, 8);
    }    
    return $$;
  }
  
  dynamic _parse_ArrayLiteral() {
    var $$;
    switch (_ch == 91 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(91, '[');
          if (!success) break;
          var seq = new List(8)..[0] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[1] = $$;
          var testing0 = _testing;
          _testing = _cursor;
          $$ = _parse_ElementList();
          success = true; 
          _testing = testing0;
          if (!success) break;
          seq[2] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[3] = $$;
          var testing1 = _testing;
          _testing = _cursor;
          $$ = _matchChar(44, ',');
          success = true; 
          _testing = testing1;
          if (!success) break;
          seq[4] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[5] = $$;
          $$ = _matchChar(93, ']');
          if (!success) break;
          seq[6] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[7] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $5 = seq[4];
            final $6 = seq[5];
            final $7 = seq[6];
            final $8 = seq[7];
            final $start = startPos0;
            $$ = new ArrayExpression($3 != null ? $3 : []);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect43);
    }
    return $$;
  }
  
  dynamic _parse_AssignmentExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[58] >= pos) {
      $$ = _getFromCache(58);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[58] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_LeftHandSideExpression();
            if (!success) break;
            var seq = new List(6)..[0] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[1] = $$;
            $$ = _matchChar(61, '=');
            if (!success) break;
            seq[2] = $$;
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[3] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[4] = $$;
            $$ = _parse_AssignmentExpression();
            if (!success) break;
            seq[5] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $start = startPos0;
              return new AssignmentExpression(AssignmentOperator.Assign, $1, $6);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_LeftHandSideExpression();
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_AssignmentOperator();
            if (!success) break;
            seq[2] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_AssignmentExpression();
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $start = startPos1;
              return new AssignmentExpression($3, $1, $5);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _parse_ConditionalExpression();
          _startPos = startPos2;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[58]) {
      _addToCache($$, pos, 58);
    }    
    return $$;
  }
  
  dynamic _parse_AssignmentExpressionNoIn() {
    var $$;
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_AssignmentOperator() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[60] >= pos) {
      $$ = _getFromCache(60);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[60] = pos;
    }  
    _token = 16;    
    _tokenStart = _cursor;    
    switch (_getState(_transitions11)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings21, '%=');
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = AssignmentOperator.ModulusAssign;
        }
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings22, '&=');
        if (success) {    
          final $1 = $$;
          final $start = startPos1;
          $$ = AssignmentOperator.BitAndAssign;
        }
        _startPos = startPos1;
        break;
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings23, '*=');
        if (success) {    
          final $1 = $$;
          final $start = startPos2;
          $$ = AssignmentOperator.MultiplyAssign;
        }
        _startPos = startPos2;
        break;
      case 3:
        var startPos3 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings24, '+=');
        if (success) {    
          final $1 = $$;
          final $start = startPos3;
          $$ = AssignmentOperator.PlusAssign;
        }
        _startPos = startPos3;
        break;
      case 4:
        var startPos4 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings25, '-=');
        if (success) {    
          final $1 = $$;
          final $start = startPos4;
          $$ = AssignmentOperator.MinusAssign;
        }
        _startPos = startPos4;
        break;
      case 5:
        var startPos5 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings26, '/=');
        if (success) {    
          final $1 = $$;
          final $start = startPos5;
          $$ = AssignmentOperator.DivideAssign;
        }
        _startPos = startPos5;
        break;
      case 6:
        var startPos6 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings27, '<<=');
        if (success) {    
          final $1 = $$;
          final $start = startPos6;
          $$ = AssignmentOperator.LeftShiftArithmeticAssign;
        }
        _startPos = startPos6;
        break;
      case 7:
        while (true) {
          var startPos7 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings28, '>>=');
          if (success) {    
            final $1 = $$;
            final $start = startPos7;
            $$ = AssignmentOperator.RightShiftArithmeticAssign;
          }
          _startPos = startPos7;
          if (success) break;
          var startPos8 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings29, '>>>=');
          if (success) {    
            final $1 = $$;
            final $start = startPos8;
            $$ = AssignmentOperator.RightShiftLogicalAssign;
          }
          _startPos = startPos8;
          break;
        }
        break;
      case 8:
        var startPos9 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings30, '^=');
        if (success) {    
          final $1 = $$;
          final $start = startPos9;
          $$ = AssignmentOperator.BitXorAssign;
        }
        _startPos = startPos9;
        break;
      case 9:
        var startPos10 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings31, '|=');
        if (success) {    
          final $1 = $$;
          final $start = startPos10;
          $$ = AssignmentOperator.BitOrAssign;
        }
        _startPos = startPos10;
        break;
      case 10:
      case 11:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect32);
    }
    if (_cacheable[60]) {
      _addToCache($$, pos, 60);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_BS() {
    var $$;
    _token = 20;  
    _tokenStart = _cursor;  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          switch (_getState(_transitions23)) {
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              $$ = _matchMapping(9, 32, _mapping8);
              _startPos = startPos1;
              break;
            case 1:
              while (true) {
                var startPos2 = _startPos;
                _startPos = _cursor;
                $$ = _matchMapping(9, 32, _mapping8);
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                $$ = _matchString(_strings32, '\r\n');
                _startPos = startPos3;
                break;
              }
              break;
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            _failure(const [null]);
          }
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect41);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_BitwiseANDExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[41] >= pos) {
      $$ = _getFromCache(41);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[41] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_EqualityExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_BitwiseANDOperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_EqualityExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect22);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[41]) {
      _addToCache($$, pos, 41);
    }    
    return $$;
  }
  
  dynamic _parse_BitwiseANDExpressionNoIn() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[42] >= pos) {
      $$ = _getFromCache(42);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[42] = pos;
    }  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[42]) {
      _addToCache($$, pos, 42);
    }    
    return $$;
  }
  
  dynamic _parse_BitwiseANDOperator() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[43] >= pos) {
      $$ = _getFromCache(43);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[43] = pos;
    }  
    _token = 11;    
    _tokenStart = _cursor;    
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(38, '&');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchMapping(38, 61, _mapping4);
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = BinaryOperator.BitAnd;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect23);
    }
    if (_cacheable[43]) {
      _addToCache($$, pos, 43);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_BitwiseORExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[47] >= pos) {
      $$ = _getFromCache(47);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[47] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_BitwiseXORExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_BitwiseOROperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_BitwiseXORExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect26);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[47]) {
      _addToCache($$, pos, 47);
    }    
    return $$;
  }
  
  dynamic _parse_BitwiseORExpressionNoIn() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[48] >= pos) {
      $$ = _getFromCache(48);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[48] = pos;
    }  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[48]) {
      _addToCache($$, pos, 48);
    }    
    return $$;
  }
  
  dynamic _parse_BitwiseOROperator() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[49] >= pos) {
      $$ = _getFromCache(49);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[49] = pos;
    }  
    _token = 13;    
    _tokenStart = _cursor;    
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(124, '|');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchMapping(61, 124, _mapping5);
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = BinaryOperator.BitOr;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect27);
    }
    if (_cacheable[49]) {
      _addToCache($$, pos, 49);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_BitwiseXORExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[44] >= pos) {
      $$ = _getFromCache(44);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[44] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_BitwiseANDExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_BitwiseXOROperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_BitwiseANDExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect24);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[44]) {
      _addToCache($$, pos, 44);
    }    
    return $$;
  }
  
  dynamic _parse_BitwiseXORExpressionNoIn() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[45] >= pos) {
      $$ = _getFromCache(45);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[45] = pos;
    }  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[45]) {
      _addToCache($$, pos, 45);
    }    
    return $$;
  }
  
  dynamic _parse_BitwiseXOROperator() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[46] >= pos) {
      $$ = _getFromCache(46);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[46] = pos;
    }  
    _token = 12;    
    _tokenStart = _cursor;    
    switch (_ch == 94 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(94, '^');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchChar(61, '=');
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = BinaryOperator.BitXOr;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect25);
    }
    if (_cacheable[46]) {
      _addToCache($$, pos, 46);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_BooleanLiteral() {
    var $$;
    _token = 2;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions4)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings5, 'false');
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = new Literal(false);
        }
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings7, 'true');
        if (success) {    
          final $1 = $$;
          final $start = startPos1;
          $$ = new Literal(true);
        }
        _startPos = startPos1;
        break;
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect8);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_CallExpression() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
            case 0:
            case 2:
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                $$ = _parse_MemberExpression();
                if (!success) break;
                var seq = new List(3)..[0] = $$;
                $$ = _parse___();
                if (!success) break;
                seq[1] = $$;
                $$ = _parse_Arguments();
                if (!success) break;
                seq[2] = $$;
                $$ = seq;
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              break;
            case 1:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            _failure(const [null]);
          }
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                while (true) {
                  var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
                  _startPos = _cursor;
                  while (true) {  
                    $$ = _parse___();
                    if (!success) break;
                    var seq = new List(2)..[0] = $$;
                    $$ = _parse_Arguments();
                    if (!success) break;
                    seq[1] = $$;
                    $$ = seq;
                    if (success) {    
                      final $1 = seq[0];
                      final $2 = seq[1];
                      final $start = startPos2;
                      $$ = [$1];
                    }
                    break;
                  }
                  if (!success) {
                    _ch = ch2;
                    _cursor = pos2;
                  }
                  _startPos = startPos2;
                  if (success) break;
                  var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
                  _startPos = _cursor;
                  while (true) {  
                    $$ = _parse___();
                    if (!success) break;
                    var seq = new List(6)..[0] = $$;
                    $$ = _matchChar(91, '[');
                    if (!success) break;
                    seq[1] = $$;
                    $$ = _parse___();
                    if (!success) break;
                    seq[2] = $$;
                    $$ = _parse_Expression();
                    if (!success) break;
                    seq[3] = $$;
                    $$ = _parse___();
                    if (!success) break;
                    seq[4] = $$;
                    $$ = _matchChar(93, ']');
                    if (!success) break;
                    seq[5] = $$;
                    $$ = seq;
                    if (success) {    
                      final $1 = seq[0];
                      final $2 = seq[1];
                      final $3 = seq[2];
                      final $4 = seq[3];
                      final $5 = seq[4];
                      final $6 = seq[5];
                      final $start = startPos3;
                      $$ = [null,$4];
                    }
                    break;
                  }
                  if (!success) {
                    _ch = ch3;
                    _cursor = pos3;
                  }
                  _startPos = startPos3;
                  if (success) break;
                  var ch4 = _ch, pos4 = _cursor, startPos4 = _startPos;
                  _startPos = _cursor;
                  while (true) {  
                    $$ = _parse___();
                    if (!success) break;
                    var seq = new List(4)..[0] = $$;
                    $$ = _matchChar(46, '.');
                    if (!success) break;
                    seq[1] = $$;
                    $$ = _parse___();
                    if (!success) break;
                    seq[2] = $$;
                    $$ = _parse_PropertyLiteral();
                    if (!success) break;
                    seq[3] = $$;
                    $$ = seq;
                    if (success) {    
                      final $1 = seq[0];
                      final $2 = seq[1];
                      final $3 = seq[2];
                      final $4 = seq[3];
                      final $start = startPos4;
                      $$ = [null,null,$4];
                    }
                    break;
                  }
                  if (!success) {
                    _ch = ch4;
                    _cursor = pos4;
                  }
                  _startPos = startPos4;
                  break;
                }
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect3);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = _buildCall($1, $2);
            /*
            if($2 == null){
              $$ = $1;
            }else{
              for(var i in $2){
                if(i[0] != null){
                  $$ = _buildCall([$1, i[0] != null ? i[0] : []]);
                }else if(i[1] != null){
                  $$ = _buildMemberExpression($1, i[1]);
                }else if(i[2] != null){
                  $$ = _buildMemberExpression($1, i[2]);
                }
              }
            }
            */
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_CharacterEscapeSequence() {
    var $$;
    switch (_getState(_transitions15)) {
      case 0:
      case 3:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_NonEscapeCharacter();
        _startPos = startPos0;
        break;
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _parse_SingleEscapeCharacter();
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _parse_NonEscapeCharacter();
          _startPos = startPos2;
          break;
        }
        break;
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_ConditionalExpression() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_LogicalORExpression();
            if (!success) break;
            var seq = new List(9)..[0] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[1] = $$;
            $$ = _matchChar(63, '?');
            if (!success) break;
            seq[2] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_AssignmentExpression();
            if (!success) break;
            seq[4] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[5] = $$;
            $$ = _matchChar(58, ':');
            if (!success) break;
            seq[6] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[7] = $$;
            $$ = _parse_AssignmentExpression();
            if (!success) break;
            seq[8] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $7 = seq[6];
              final $8 = seq[7];
              final $9 = seq[8];
              final $start = startPos0;
              return new ConditionalExpression($1, $5, $9);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LogicalORExpression();
          _startPos = startPos1;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_ConditionalExpressionNoIn() {
    var $$;
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_DecimalDigit() {
    var $$;
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchRange(48, 57);
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_DoubleStringCharacter() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            switch (_getState(_transitions13)) {
              case 0:
                var startPos1 = _startPos;
                _startPos = _cursor;
                $$ = _parse_LineTerminator();
                _startPos = startPos1;
                break;
              case 1:
                var startPos2 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(34, '\"');
                _startPos = startPos2;
                break;
              case 2:
                var startPos3 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(92, '\\');
                _startPos = startPos3;
                break;
              case 3:
              case 4:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(const [null]);
            }
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_SourceCharacter();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos0;
              return $2;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(92, '\\');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_EscapeSequence();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos4;
              return $1+$2;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LineContinuation();
          _startPos = startPos5;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
      case 2:
        while (true) {
          var ch3 = _ch, pos3 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            var ch4 = _ch, pos4 = _cursor, testing1 = _testing; 
            _testing = _inputLen + 1;
            switch (_getState(_transitions13)) {
              case 0:
                var startPos7 = _startPos;
                _startPos = _cursor;
                $$ = _parse_LineTerminator();
                _startPos = startPos7;
                break;
              case 1:
                var startPos8 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(34, '\"');
                _startPos = startPos8;
                break;
              case 2:
                var startPos9 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(92, '\\');
                _startPos = startPos9;
                break;
              case 3:
              case 4:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(const [null]);
            }
            _ch = ch4;
            _cursor = pos4; 
            _testing = testing1;
            $$ = null;
            success = !success;
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_SourceCharacter();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos6;
              return $2;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos6;
          if (success) break;
          var ch5 = _ch, pos5 = _cursor, startPos10 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(92, '\\');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_EscapeSequence();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos10;
              return $1+$2;
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos10;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_EOF() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[81] >= pos) {
      $$ = _getFromCache(81);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[81] = pos;
    }  
    _token = 19;    
    _tokenStart = _cursor;    
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        var ch0 = _ch, pos0 = _cursor, testing0 = _testing; 
        _testing = _inputLen + 1;
        $$ = _matchAny();
        _ch = ch0;
        _cursor = pos0; 
        _testing = testing0;
        $$ = null;
        success = !success;
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect40);
    }
    if (_cacheable[81]) {
      _addToCache($$, pos, 81);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ElementList() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_AssignmentExpression();
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[1] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _matchChar(44, ',');
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_WS();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse_AssignmentExpression();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_WS();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  if (success) {    
                    final $1 = seq[0];
                    final $2 = seq[1];
                    final $3 = seq[2];
                    final $4 = seq[3];
                    final $start = startPos1;
                    $$ = $3;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect1);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _buildList($1, $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_EqualityExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[38] >= pos) {
      $$ = _getFromCache(38);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[38] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_RelationalExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_EqualityOperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_RelationalExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect20);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[38]) {
      _addToCache($$, pos, 38);
    }    
    return $$;
  }
  
  dynamic _parse_EqualityExpressionNoIn() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[39] >= pos) {
      $$ = _getFromCache(39);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[39] = pos;
    }  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[39]) {
      _addToCache($$, pos, 39);
    }    
    return $$;
  }
  
  dynamic _parse_EqualityOperator() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[40] >= pos) {
      $$ = _getFromCache(40);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[40] = pos;
    }  
    _token = 10;    
    _tokenStart = _cursor;    
    switch (_getState(_transitions10)) {
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings15, '!==');
          if (success) {    
            final $1 = $$;
            final $start = startPos0;
            $$ = BinaryOperator.IdentityNotEquals;
          }
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings16, '!=');
          if (success) {    
            final $1 = $$;
            final $start = startPos1;
            $$ = BinaryOperator.NotEquals;
          }
          _startPos = startPos1;
          break;
        }
        break;
      case 1:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings17, '===');
          if (success) {    
            final $1 = $$;
            final $start = startPos2;
            $$ = BinaryOperator.IdentityEquals;
          }
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings18, '==');
          if (success) {    
            final $1 = $$;
            final $start = startPos3;
            $$ = BinaryOperator.Equals;
          }
          _startPos = startPos3;
          break;
        }
        break;
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect21);
    }
    if (_cacheable[40]) {
      _addToCache($$, pos, 40);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_EscapeCharacter() {
    var $$;
    switch (_getState(_transitions18)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_SingleEscapeCharacter();
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _parse_DecimalDigit();
        _startPos = startPos1;
        break;
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(117, 'u');
        _startPos = startPos2;
        break;
      case 3:
        var startPos3 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(120, 'x');
        _startPos = startPos3;
        break;
      case 4:
      case 5:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_EscapeSequence() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          $$ = _parse_CharacterEscapeSequence();
          _startPos = startPos0;
          if (success) break;
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(48, '0');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            $$ = _parse_DecimalDigit();
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos1;
              return "\0";
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _parse_HexEscapeSequence();
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          $$ = _parse_UnicodeEscapeSequence();
          _startPos = startPos3;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
      case 2:
        while (true) {
          var startPos4 = _startPos;
          _startPos = _cursor;
          $$ = _parse_CharacterEscapeSequence();
          _startPos = startPos4;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(48, '0');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
            _testing = _inputLen + 1;
            $$ = _parse_DecimalDigit();
            _ch = ch3;
            _cursor = pos3; 
            _testing = testing1;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos5;
              return "\0";
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos5;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_Expression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[2] >= pos) {
      $$ = _getFromCache(2);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[2] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_AssignmentExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _matchChar(44, ',');
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_AssignmentExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  if (success) {    
                    final $1 = seq[0];
                    final $2 = seq[1];
                    final $3 = seq[2];
                    final $4 = seq[3];
                    final $start = startPos1;
                    $$ = $4;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect0);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return $2.length > 0
              ? new SequenceExpression(_buildList($1, $2))
              : $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[2]) {
      _addToCache($$, pos, 2);
    }    
    return $$;
  }
  
  dynamic _parse_ForExpressionDecl() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_WS();
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_Identifier();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos0;
              $$ = { "value" : $2.name, "index":"" };
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_WS();
            if (!success) break;
            var seq = new List(10)..[0] = $$;
            $$ = _matchChar(40, '(');
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[2] = $$;
            $$ = _parse_Identifier();
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[4] = $$;
            $$ = _matchChar(44, ',');
            if (!success) break;
            seq[5] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[6] = $$;
            $$ = _parse_Identifier();
            if (!success) break;
            seq[7] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[8] = $$;
            $$ = _matchChar(41, ')');
            if (!success) break;
            seq[9] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $7 = seq[6];
              final $8 = seq[7];
              final $9 = seq[8];
              final $10 = seq[9];
              final $start = startPos1;
              $$ = { "value" : $4.name, "index":$8.name };
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_WS();
            if (!success) break;
            var seq = new List(10)..[0] = $$;
            $$ = _matchChar(40, '(');
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[2] = $$;
            $$ = _parse_Identifier();
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[4] = $$;
            $$ = _matchChar(58, ':');
            if (!success) break;
            seq[5] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[6] = $$;
            $$ = _parse_Identifier();
            if (!success) break;
            seq[7] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[8] = $$;
            $$ = _matchChar(41, ')');
            if (!success) break;
            seq[9] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $7 = seq[6];
              final $8 = seq[7];
              final $9 = seq[8];
              final $10 = seq[9];
              final $start = startPos2;
              $$ = { "value" : $8.name, "index":$4.name };
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_HexDigit() {
    var $$;
    switch (_getState(_transitions19)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchMapping(48, 102, _mapping6);
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_HexEscapeSequence() {
    var $$;
    switch (_ch == 120 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(120, 'x');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          switch (_getState(_transitions19)) {
            case 0:
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                $$ = _parse_HexDigit();
                if (!success) break;
                var seq = new List(2)..[0] = $$;
                $$ = _parse_HexDigit();
                if (!success) break;
                seq[1] = $$;
                $$ = seq;
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              break;
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            _failure(const [null]);
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect36);
    }
    return $$;
  }
  
  dynamic _parse_Identifier() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[17] >= pos) {
      $$ = _getFromCache(17);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[17] = pos;
    }  
    switch (_getState(_transitions2)) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _parse_ReservedWord();
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          $$ = _matchMapping(36, 122, _mapping0);
          if (!success) break;
          seq[1] = $$;
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            $$ = _matchMapping(36, 122, _mapping1);
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[2] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Identifier($2 + $3.join(''));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[17]) {
      _addToCache($$, pos, 17);
    }    
    return $$;
  }
  
  dynamic _parse_LambdaExpression() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_WS();
            if (!success) break;
            var seq = new List(10)..[0] = $$;
            $$ = _matchChar(40, '(');
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[2] = $$;
            var testing0 = _testing;
            _testing = _cursor;
            $$ = _parse_PropertyLiteralList();
            success = true; 
            _testing = testing0;
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[4] = $$;
            $$ = _matchChar(41, ')');
            if (!success) break;
            seq[5] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[6] = $$;
            $$ = _matchString(_strings0, '=>');
            if (!success) break;
            seq[7] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[8] = $$;
            $$ = _parse_SingleExpression();
            if (!success) break;
            seq[9] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $7 = seq[6];
              final $8 = seq[7];
              final $9 = seq[8];
              final $10 = seq[9];
              final $start = startPos0;
              $$ = _buildLambda($4 == null ? [] : $4, $10);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_WS();
            if (!success) break;
            var seq = new List(6)..[0] = $$;
            $$ = _parse_PropertyLiteral();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[2] = $$;
            $$ = _matchString(_strings0, '=>');
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[4] = $$;
            $$ = _parse_SingleExpression();
            if (!success) break;
            seq[5] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $start = startPos1;
              $$ = _buildLambda([$2], $6);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_LeftHandSideExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[23] >= pos) {
      $$ = _getFromCache(23);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[23] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          $$ = _parse_CallExpression();
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _parse_MemberExpression();
          _startPos = startPos1;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[23]) {
      _addToCache($$, pos, 23);
    }    
    return $$;
  }
  
  dynamic _parse_LineContinuation() {
    var $$;
    switch (_ch == 92 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(92, '\\');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          $$ = _parse_LineTerminatorSequence();
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return "";
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect34);
    }
    return $$;
  }
  
  dynamic _parse_LineTerminator() {
    var $$;
    switch (_getState(_transitions20)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchMapping(10, 13, _mapping7);
        if (!success) {
          $$ = _matchRanges(_ranges0);
        }
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_LineTerminatorSequence() {
    var $$;
    switch (_getState(_transitions21)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(10, '\n');
        _startPos = startPos0;
        break;
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings32, '\r\n');
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _matchChar(13, '\r');
          _startPos = startPos2;
          break;
        }
        break;
      case 2:
        var startPos3 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(8232, '\u2028');
        _startPos = startPos3;
        break;
      case 3:
        var startPos4 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(8233, '\u2029');
        _startPos = startPos4;
        break;
      case 4:
      case 5:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect38);
    }
    return $$;
  }
  
  dynamic _parse_Literal() {
    var $$;
    switch (_getState(_transitions3)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_StringLiteral();
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _parse_NumericLiteral();
        _startPos = startPos1;
        break;
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        $$ = _parse_BooleanLiteral();
        _startPos = startPos2;
        break;
      case 3:
        var startPos3 = _startPos;
        _startPos = _cursor;
        $$ = _parse_NullLiteral();
        _startPos = startPos3;
        break;
      case 4:
        $$ = null;
        success = false;
        break;
      case 5:
        while (true) {
          var startPos4 = _startPos;
          _startPos = _cursor;
          $$ = _parse_NumericLiteral();
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          $$ = _parse_StringLiteral();
          _startPos = startPos5;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_LogicalANDExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[50] >= pos) {
      $$ = _getFromCache(50);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[50] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_BitwiseORExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_LogicalANDOperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_BitwiseORExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect28);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildLogicalExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[50]) {
      _addToCache($$, pos, 50);
    }    
    return $$;
  }
  
  dynamic _parse_LogicalANDExpressionNoIn() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[51] >= pos) {
      $$ = _getFromCache(51);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[51] = pos;
    }  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[51]) {
      _addToCache($$, pos, 51);
    }    
    return $$;
  }
  
  dynamic _parse_LogicalANDOperator() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[52] >= pos) {
      $$ = _getFromCache(52);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[52] = pos;
    }  
    _token = 14;    
    _tokenStart = _cursor;    
    switch (_ch == 38 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings19, '&&');
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = LogicalOperator.And;
        }
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect29);
    }
    if (_cacheable[52]) {
      _addToCache($$, pos, 52);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_LogicalORExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[53] >= pos) {
      $$ = _getFromCache(53);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[53] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_LogicalANDExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_LogicalOROperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_LogicalANDExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect30);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildLogicalExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[53]) {
      _addToCache($$, pos, 53);
    }    
    return $$;
  }
  
  dynamic _parse_LogicalORExpressionNoIn() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[54] >= pos) {
      $$ = _getFromCache(54);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[54] = pos;
    }  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[54]) {
      _addToCache($$, pos, 54);
    }    
    return $$;
  }
  
  dynamic _parse_LogicalOROperator() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[55] >= pos) {
      $$ = _getFromCache(55);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[55] = pos;
    }  
    _token = 15;    
    _tokenStart = _cursor;    
    switch (_ch == 124 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings20, '||');
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = LogicalOperator.Or;
        }
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect31);
    }
    if (_cacheable[55]) {
      _addToCache($$, pos, 55);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_MemberExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[6] >= pos) {
      $$ = _getFromCache(6);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[6] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_PrimaryExpression();
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[1] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                while (true) {
                  var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                  _startPos = _cursor;
                  while (true) {  
                    $$ = _parse___();
                    if (!success) break;
                    var seq = new List(6)..[0] = $$;
                    $$ = _matchChar(91, '[');
                    if (!success) break;
                    seq[1] = $$;
                    $$ = _parse___();
                    if (!success) break;
                    seq[2] = $$;
                    $$ = _parse_Expression();
                    if (!success) break;
                    seq[3] = $$;
                    $$ = _parse___();
                    if (!success) break;
                    seq[4] = $$;
                    $$ = _matchChar(93, ']');
                    if (!success) break;
                    seq[5] = $$;
                    $$ = seq;
                    if (success) {    
                      final $1 = seq[0];
                      final $2 = seq[1];
                      final $3 = seq[2];
                      final $4 = seq[3];
                      final $5 = seq[4];
                      final $6 = seq[5];
                      final $start = startPos1;
                      $$ = $4;
                    }
                    break;
                  }
                  if (!success) {
                    _ch = ch1;
                    _cursor = pos1;
                  }
                  _startPos = startPos1;
                  if (success) break;
                  var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
                  _startPos = _cursor;
                  while (true) {  
                    $$ = _parse___();
                    if (!success) break;
                    var seq = new List(4)..[0] = $$;
                    $$ = _matchChar(46, '.');
                    if (!success) break;
                    seq[1] = $$;
                    $$ = _parse___();
                    if (!success) break;
                    seq[2] = $$;
                    $$ = _parse_PropertyLiteral();
                    if (!success) break;
                    seq[3] = $$;
                    $$ = seq;
                    if (success) {    
                      final $1 = seq[0];
                      final $2 = seq[1];
                      final $3 = seq[2];
                      final $4 = seq[3];
                      final $start = startPos2;
                      $$ = $4;
                    }
                    break;
                  }
                  if (!success) {
                    _ch = ch2;
                    _cursor = pos2;
                  }
                  _startPos = startPos2;
                  break;
                }
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect2);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _buildMemberExpression($1, $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[6]) {
      _addToCache($$, pos, 6);
    }    
    return $$;
  }
  
  dynamic _parse_MultiplicativeExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[28] >= pos) {
      $$ = _getFromCache(28);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[28] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_UnaryExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_MultiplicativeOperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_UnaryExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect11);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[28]) {
      _addToCache($$, pos, 28);
    }    
    return $$;
  }
  
  dynamic _parse_MultiplicativeOperator() {
    var $$;
    _token = 5;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions7)) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(37, '%');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchChar(61, '=');
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = BinaryOperator.Modulus;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        var ch2 = _ch, pos2 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(42, '*');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchChar(61, '=');
          _ch = ch3;
          _cursor = pos3; 
          _testing = testing1;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos1;
            $$ = BinaryOperator.Multiply;
          }
          break;
        }
        if (!success) {
          _ch = ch2;
          _cursor = pos2;
        }
        _startPos = startPos1;
        break;
      case 2:
        var ch4 = _ch, pos4 = _cursor, startPos2 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(47, '/');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch5 = _ch, pos5 = _cursor, testing2 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchChar(61, '=');
          _ch = ch5;
          _cursor = pos5; 
          _testing = testing2;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos2;
            $$ = BinaryOperator.Divide;
          }
          break;
        }
        if (!success) {
          _ch = ch4;
          _cursor = pos4;
        }
        _startPos = startPos2;
        break;
      case 3:
        $$ = null;
        success = false;
        break;
      case 4:
        while (true) {
          var ch6 = _ch, pos6 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(42, '*');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch7 = _ch, pos7 = _cursor, testing3 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch7;
            _cursor = pos7; 
            _testing = testing3;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos3;
              $$ = BinaryOperator.Multiply;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos3;
          if (success) break;
          var ch8 = _ch, pos8 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(47, '/');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch9 = _ch, pos9 = _cursor, testing4 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch9;
            _cursor = pos9; 
            _testing = testing4;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos4;
              $$ = BinaryOperator.Divide;
            }
            break;
          }
          if (!success) {
            _ch = ch8;
            _cursor = pos8;
          }
          _startPos = startPos4;
          if (success) break;
          var ch10 = _ch, pos10 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(37, '%');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch11 = _ch, pos11 = _cursor, testing5 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch11;
            _cursor = pos11; 
            _testing = testing5;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos5;
              $$ = BinaryOperator.Modulus;
            }
            break;
          }
          if (!success) {
            _ch = ch10;
            _cursor = pos10;
          }
          _startPos = startPos5;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect12);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_NUMBER() {
    var $$;
    switch (_getState(_transitions22)) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          var testing0;
          for (var first = true, reps; ;) {  
            $$ = _matchRange(48, 57);  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = new Literal(int.parse($1.join('')));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
      case 3:
        while (true) {
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchRange(49, 57);
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            var testing1;
            for (var first = true, reps; ;) {  
              $$ = _matchRange(48, 57);  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing1 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing1;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            if (!success) break;
            seq[1] = $$;
            $$ = _matchChar(46, '.');
            if (!success) break;
            seq[2] = $$;
            var testing2;
            for (var first = true, reps; ;) {  
              $$ = _matchRange(48, 57);  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing2 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing2;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $start = startPos1;
              $$ = new Literal(double.parse($1 + $2.join('') + "." + $4.join('')));
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            var testing3;
            for (var first = true, reps; ;) {  
              $$ = _matchRange(48, 57);  
              if (success) {
               if (first) {      
                  first = false;
                  reps = [$$];
                  testing3 = _testing;                  
                } else {
                  reps.add($$);
                }
                _testing = _cursor;   
              } else {
                success = !first;
                if (success) {      
                  _testing = testing3;
                  $$ = reps;      
                } else $$ = null;
                break;
              }  
            }
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos2;
              $$ = new Literal(int.parse($1.join('')));
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          break;
        }
        break;
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_NonEscapeCharacter() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          switch (_getState(_transitions17)) {
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              $$ = _parse_LineTerminator();
              _startPos = startPos1;
              break;
            case 1:
              var startPos2 = _startPos;
              _startPos = _cursor;
              $$ = _parse_EscapeCharacter();
              _startPos = startPos2;
              break;
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            _failure(const [null]);
          }
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          $$ = _parse_SourceCharacter();
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return $1;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_NullLiteral() {
    var $$;
    _token = 1;  
    _tokenStart = _cursor;  
    switch (_ch == 110 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings6, 'null');
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = new Literal(null);
        }
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect7);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_NumericLiteral() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[22] >= pos) {
      $$ = _getFromCache(22);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[22] = pos;
    }  
    switch (_ch >= 48 && _ch <= 57 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_NUMBER();
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[22]) {
      _addToCache($$, pos, 22);
    }    
    return $$;
  }
  
  dynamic _parse_ObjectLiteral() {
    var $$;
    switch (_ch == 123 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(123, '{');
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[1] = $$;
            $$ = _matchChar(125, '}');
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $start = startPos0;
              $$ = new ObjectExpression({});
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(123, '{');
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_propertyNameAndValueList();
            if (!success) break;
            seq[2] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[3] = $$;
            $$ = _matchChar(125, '}');
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $start = startPos1;
              $$ = new ObjectExpression($3);
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos1;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(123, '{');
            if (!success) break;
            var seq = new List(7)..[0] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_propertyNameAndValueList();
            if (!success) break;
            seq[2] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[3] = $$;
            var testing0 = _testing;
            _testing = _cursor;
            $$ = _matchChar(44, ',');
            success = true; 
            _testing = testing0;
            if (!success) break;
            seq[4] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[5] = $$;
            $$ = _matchChar(125, '}');
            if (!success) break;
            seq[6] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $7 = seq[6];
              final $start = startPos2;
              $$ = new ObjectExpression($3);
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect42);
    }
    return $$;
  }
  
  dynamic _parse_PostfixExpression() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_LeftHandSideExpression();
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            $$ = _parse__();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_PostfixOperator();
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $start = startPos0;
              return new UpdateExpression($3, $1, false);
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LeftHandSideExpression();
          _startPos = startPos1;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_PostfixOperator() {
    var $$;
    _token = 3;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions5)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings8, '++');
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = UpdateOperator.PlusPlus;
        }
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings9, '--');
        if (success) {    
          final $1 = $$;
          final $start = startPos1;
          $$ = UpdateOperator.MinusMinus;
        }
        _startPos = startPos1;
        break;
      case 2:
      case 3:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect9);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_PrimaryExpression() {
    var $$;
    switch (_getState(_transitions0)) {
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LambdaExpression();
          _startPos = startPos0;
          if (success) break;
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Identifier();
          _startPos = startPos1;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Literal();
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          $$ = _parse_ArrayLiteral();
          _startPos = startPos3;
          if (success) break;
          var ch0 = _ch, pos0 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(40, '(');
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_Expression();
            if (!success) break;
            seq[2] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[3] = $$;
            $$ = _matchChar(41, ')');
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $start = startPos4;
              return $3;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos4;
          break;
        }
        break;
      case 1:
        while (true) {
          var startPos5 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings4, 'this');
          if (success) {    
            final $1 = $$;
            final $start = startPos5;
            return new ThisExpression();
          }
          _startPos = startPos5;
          if (success) break;
          var startPos6 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LambdaExpression();
          _startPos = startPos6;
          if (success) break;
          var startPos7 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Identifier();
          _startPos = startPos7;
          if (success) break;
          var startPos8 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Literal();
          _startPos = startPos8;
          break;
        }
        break;
      case 2:
        while (true) {
          var startPos9 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LambdaExpression();
          _startPos = startPos9;
          if (success) break;
          var startPos10 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Identifier();
          _startPos = startPos10;
          if (success) break;
          var startPos11 = _startPos;
          _startPos = _cursor;
          $$ = _parse_ObjectLiteral();
          _startPos = startPos11;
          break;
        }
        break;
      case 3:
        $$ = null;
        success = false;
        break;
      case 4:
        while (true) {
          var startPos12 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LambdaExpression();
          _startPos = startPos12;
          if (success) break;
          var startPos13 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Identifier();
          _startPos = startPos13;
          if (success) break;
          var startPos14 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Literal();
          _startPos = startPos14;
          if (success) break;
          var startPos15 = _startPos;
          _startPos = _cursor;
          $$ = _parse_ObjectLiteral();
          _startPos = startPos15;
          if (success) break;
          var startPos16 = _startPos;
          _startPos = _cursor;
          $$ = _parse_ArrayLiteral();
          _startPos = startPos16;
          if (success) break;
          var ch1 = _ch, pos1 = _cursor, startPos17 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(40, '(');
            if (!success) break;
            var seq = new List(5)..[0] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_Expression();
            if (!success) break;
            seq[2] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[3] = $$;
            $$ = _matchChar(41, ')');
            if (!success) break;
            seq[4] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $start = startPos17;
              return $3;
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos17;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_PropertyLiteral() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[18] >= pos) {
      $$ = _getFromCache(18);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[18] = pos;
    }  
    switch (_getState(_transitions2)) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _parse_ReservedWord();
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          $$ = _matchMapping(36, 122, _mapping0);
          if (!success) break;
          seq[1] = $$;
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            $$ = _matchMapping(36, 122, _mapping1);
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[2] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $start = startPos0;
            $$ = new Literal($2 + $3.join(''));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[18]) {
      _addToCache($$, pos, 18);
    }    
    return $$;
  }
  
  dynamic _parse_PropertyLiteralList() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_WS();
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          $$ = _parse_PropertyLiteral();
          if (!success) break;
          seq[1] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[2] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _matchChar(44, ',');
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_WS();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse_PropertyLiteral();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_WS();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  if (success) {    
                    final $1 = seq[0];
                    final $2 = seq[1];
                    final $3 = seq[2];
                    final $4 = seq[3];
                    final $start = startPos1;
                    $$= $3;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect1);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $start = startPos0;
            $$ = [$2]..addAll($4);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_RelationalExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[34] >= pos) {
      $$ = _getFromCache(34);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[34] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_ShiftExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_RelationalOperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_ShiftExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect17);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[34]) {
      _addToCache($$, pos, 34);
    }    
    return $$;
  }
  
  dynamic _parse_RelationalExpressionNoIn() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[36] >= pos) {
      $$ = _getFromCache(36);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[36] = pos;
    }  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[36]) {
      _addToCache($$, pos, 36);
    }    
    return $$;
  }
  
  dynamic _parse_RelationalOperator() {
    var $$;
    _token = 8;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions8)) {
      case 0:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings13, '<=');
          if (success) {    
            final $1 = $$;
            final $start = startPos0;
            $$ = BinaryOperator.LessThanEquals;
          }
          _startPos = startPos0;
          if (success) break;
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(60, '<');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(60, '<');
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos1;
              $$ = BinaryOperator.LessThan;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          break;
        }
        break;
      case 1:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings14, '>=');
          if (success) {    
            final $1 = $$;
            final $start = startPos2;
            $$ = BinaryOperator.GreaterThanEquals;
          }
          _startPos = startPos2;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(62, '>');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(62, '>');
            _ch = ch3;
            _cursor = pos3; 
            _testing = testing1;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos3;
              $$ = BinaryOperator.MoreThan;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos3;
          break;
        }
        break;
      case 2:
        $$ = null;
        success = false;
        break;
      case 3:
        while (true) {
          var ch4 = _ch, pos4 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(60, '<');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch5 = _ch, pos5 = _cursor, testing2 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(60, '<');
            _ch = ch5;
            _cursor = pos5; 
            _testing = testing2;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos4;
              $$ = BinaryOperator.LessThan;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos4;
          if (success) break;
          var ch6 = _ch, pos6 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(62, '>');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch7 = _ch, pos7 = _cursor, testing3 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(62, '>');
            _ch = ch7;
            _cursor = pos7; 
            _testing = testing3;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos5;
              $$ = BinaryOperator.MoreThan;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos5;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect18);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_RelationalOperatorNoIn() {
    var $$;
    _token = 9;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions9)) {
      case 0:
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect19);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ReservedWord() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[16] >= pos) {
      $$ = _getFromCache(16);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[16] = pos;
    }  
    _token = 0;    
    _tokenStart = _cursor;    
    switch (_getState(_transitions1)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings5, 'false');
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _matchString(_strings6, 'null');
        _startPos = startPos1;
        break;
      case 2:
        while (true) {
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings4, 'this');
          _startPos = startPos2;
          if (success) break;
          var startPos3 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings7, 'true');
          _startPos = startPos3;
          break;
        }
        break;
      case 3:
      case 4:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect6);
    }
    if (_cacheable[16]) {
      _addToCache($$, pos, 16);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_ShiftExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[32] >= pos) {
      $$ = _getFromCache(32);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[32] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_AdditiveExpression();
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _parse___();
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_ShiftOperator();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse___();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_AdditiveExpression();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect15);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            return buildBinaryExpression($1, $2);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[32]) {
      _addToCache($$, pos, 32);
    }    
    return $$;
  }
  
  dynamic _parse_ShiftOperator() {
    var $$;
    _token = 7;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions8)) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchString(_strings10, '<<');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
          _testing = _inputLen + 1;
          $$ = _matchChar(61, '=');
          _ch = ch1;
          _cursor = pos1; 
          _testing = testing0;
          $$ = null;
          success = !success;
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            $$ = BinaryOperator.LeftShiftArithmetic;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        while (true) {
          var ch2 = _ch, pos2 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchString(_strings11, '>>>');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch3;
            _cursor = pos3; 
            _testing = testing1;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos1;
              $$ = BinaryOperator.RightShiftLogical;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos1;
          if (success) break;
          var ch4 = _ch, pos4 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchString(_strings12, '>>');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch5 = _ch, pos5 = _cursor, testing2 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch5;
            _cursor = pos5; 
            _testing = testing2;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos2;
              $$ = BinaryOperator.RightShiftArithmetic;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos2;
          break;
        }
        break;
      case 2:
        $$ = null;
        success = false;
        break;
      case 3:
        while (true) {
          var ch6 = _ch, pos6 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchString(_strings10, '<<');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch7 = _ch, pos7 = _cursor, testing3 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch7;
            _cursor = pos7; 
            _testing = testing3;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos3;
              $$ = BinaryOperator.LeftShiftArithmetic;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos3;
          if (success) break;
          var ch8 = _ch, pos8 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchString(_strings11, '>>>');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch9 = _ch, pos9 = _cursor, testing4 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch9;
            _cursor = pos9; 
            _testing = testing4;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos4;
              $$ = BinaryOperator.RightShiftLogical;
            }
            break;
          }
          if (!success) {
            _ch = ch8;
            _cursor = pos8;
          }
          _startPos = startPos4;
          if (success) break;
          var ch10 = _ch, pos10 = _cursor, startPos5 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchString(_strings12, '>>');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch11 = _ch, pos11 = _cursor, testing5 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch11;
            _cursor = pos11; 
            _testing = testing5;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos5;
              $$ = BinaryOperator.RightShiftArithmetic;
            }
            break;
          }
          if (!success) {
            _ch = ch10;
            _cursor = pos10;
          }
          _startPos = startPos5;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect16);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_SingleEscapeCharacter() {
    var $$;
    switch (_getState(_transitions16)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(34, '\"');
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(39, '\'');
        _startPos = startPos1;
        break;
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(92, '\\');
        _startPos = startPos2;
        break;
      case 3:
        var startPos3 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(98, 'b');
        if (success) {    
          final $1 = $$;
          final $start = startPos3;
          return "\b";
        }
        _startPos = startPos3;
        break;
      case 4:
        var startPos4 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(102, 'f');
        if (success) {    
          final $1 = $$;
          final $start = startPos4;
          return "\f";
        }
        _startPos = startPos4;
        break;
      case 5:
        var startPos5 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(110, 'n');
        if (success) {    
          final $1 = $$;
          final $start = startPos5;
          return "\n";
        }
        _startPos = startPos5;
        break;
      case 6:
        var startPos6 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(114, 'r');
        if (success) {    
          final $1 = $$;
          final $start = startPos6;
          return "\r";
        }
        _startPos = startPos6;
        break;
      case 7:
        var startPos7 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(116, 't');
        if (success) {    
          final $1 = $$;
          final $start = startPos7;
          return "\t";
        }
        _startPos = startPos7;
        break;
      case 8:
        var startPos8 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(118, 'v');
        if (success) {    
          final $1 = $$;
          final $start = startPos8;
          return "\v";
        }
        _startPos = startPos8;
        break;
      case 9:
      case 10:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect35);
    }
    return $$;
  }
  
  dynamic _parse_SingleExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[3] >= pos) {
      $$ = _getFromCache(3);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[3] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_WS();
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          $$ = _parse_AssignmentExpression();
          if (!success) break;
          seq[1] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[3]) {
      _addToCache($$, pos, 3);
    }    
    return $$;
  }
  
  dynamic _parse_SingleStringCharacter() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            switch (_getState(_transitions14)) {
              case 0:
                var startPos1 = _startPos;
                _startPos = _cursor;
                $$ = _parse_LineTerminator();
                _startPos = startPos1;
                break;
              case 1:
                var startPos2 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(39, '\'');
                _startPos = startPos2;
                break;
              case 2:
                var startPos3 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(92, '\\');
                _startPos = startPos3;
                break;
              case 3:
              case 4:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(const [null]);
            }
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_SourceCharacter();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos0;
              return $2;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(92, '\\');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_EscapeSequence();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos4;
              return $1+$2;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          $$ = _parse_LineContinuation();
          _startPos = startPos5;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
      case 2:
        while (true) {
          var ch3 = _ch, pos3 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            var ch4 = _ch, pos4 = _cursor, testing1 = _testing; 
            _testing = _inputLen + 1;
            switch (_getState(_transitions14)) {
              case 0:
                var startPos7 = _startPos;
                _startPos = _cursor;
                $$ = _parse_LineTerminator();
                _startPos = startPos7;
                break;
              case 1:
                var startPos8 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(39, '\'');
                _startPos = startPos8;
                break;
              case 2:
                var startPos9 = _startPos;
                _startPos = _cursor;
                $$ = _matchChar(92, '\\');
                _startPos = startPos9;
                break;
              case 3:
              case 4:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(const [null]);
            }
            _ch = ch4;
            _cursor = pos4; 
            _testing = testing1;
            $$ = null;
            success = !success;
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_SourceCharacter();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos6;
              return $2;
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos6;
          if (success) break;
          var ch5 = _ch, pos5 = _cursor, startPos10 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(92, '\\');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            $$ = _parse_EscapeSequence();
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos10;
              return $1+$2;
            }
            break;
          }
          if (!success) {
            _ch = ch5;
            _cursor = pos5;
          }
          _startPos = startPos10;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_SourceCharacter() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchAny();
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_StringLiteral() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[61] >= pos) {
      $$ = _getFromCache(61);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[61] = pos;
    }  
    _token = 17;    
    _tokenStart = _cursor;    
    switch (_getState(_transitions12)) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(34, '\"');
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            $$ = _parse_DoubleStringCharacter();
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = _matchChar(34, '\"');
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $start = startPos0;
            return new Literal($2.join(""));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(39, '\'');
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          var testing1 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            $$ = _parse_SingleStringCharacter();
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing1;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[1] = $$;
          $$ = _matchChar(39, '\'');
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $start = startPos1;
            return new Literal($2.join(""));
          }
          break;
        }
        if (!success) {
          _ch = ch1;
          _cursor = pos1;
        }
        _startPos = startPos1;
        break;
      case 2:
        $$ = null;
        success = false;
        break;
      case 3:
        while (true) {
          var ch2 = _ch, pos2 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(34, '\"');
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            var testing2 = _testing; 
            for (var reps = []; ; ) {
              _testing = _cursor;
              $$ = _parse_DoubleStringCharacter();
              if (success) {  
                reps.add($$);
              } else {
                success = true;
                _testing = testing2;
                $$ = reps;
                break; 
              }
            }
            if (!success) break;
            seq[1] = $$;
            $$ = _matchChar(34, '\"');
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $start = startPos2;
              return new Literal($2.join(""));
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos2;
          if (success) break;
          var ch3 = _ch, pos3 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(39, '\'');
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            var testing3 = _testing; 
            for (var reps = []; ; ) {
              _testing = _cursor;
              $$ = _parse_SingleStringCharacter();
              if (success) {  
                reps.add($$);
              } else {
                success = true;
                _testing = testing3;
                $$ = reps;
                break; 
              }
            }
            if (!success) break;
            seq[1] = $$;
            $$ = _matchChar(39, '\'');
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $start = startPos3;
              return new Literal($2.join(""));
            }
            break;
          }
          if (!success) {
            _ch = ch3;
            _cursor = pos3;
          }
          _startPos = startPos3;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect33);
    }
    if (_cacheable[61]) {
      _addToCache($$, pos, 61);
    }    
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_TemplateText() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_BS();
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          var testing0;
          for (var first = true, reps; ;) {  
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {  
              case 0:  
              case 2:  
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;  
                _startPos = _cursor;  
                while (true) {    
                  $$ = _matchAny();  
                  if (!success) break;  
                  var seq = new List(2)..[0] = $$;  
                  var ch2 = _ch, pos2 = _cursor, testing1 = _testing;   
                  _testing = _inputLen + 1;  
                  $$ = _matchChar(123, '{');  
                  _ch = ch2;  
                  _cursor = pos2;   
                  _testing = testing1;  
                  $$ = null;  
                  success = !success;  
                  if (!success) break;  
                  seq[1] = $$;  
                  $$ = seq;  
                  if (success) {      
                    final $1 = seq[0];  
                    final $2 = seq[1];  
                    final $start = startPos1;  
                    $$ = $1;  
                  }  
                  break;  
                }  
                if (!success) {  
                  _ch = ch1;  
                  _cursor = pos1;  
                }  
                _startPos = startPos1;  
                break;  
              case 1:  
                $$ = null;  
                success = false;  
                break;  
            }  
            if (!success && _cursor > _testing) {  
              _failure(const [null]);  
            }  
            if (success) {
             if (first) {      
                first = false;
                reps = [$$];
                testing0 = _testing;                  
              } else {
                reps.add($$);
              }
              _testing = _cursor;   
            } else {
              success = !first;
              if (success) {      
                _testing = testing0;
                $$ = reps;      
              } else $$ = null;
              break;
            }  
          }
          if (!success) break;
          seq[1] = $$;
          $$ = _parse_BS();
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $start = startPos0;
            $$ = new Literal($1.join('') + $2.join('') + $3.join(''));
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_TemplateUnit() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_BS();
            if (!success) break;
            var seq = new List(6)..[0] = $$;
            $$ = _matchString(_strings2, '{{');
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[2] = $$;
            switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var startPos1 = _startPos;
                _startPos = _cursor;
                $$ = _parse_AssignmentExpression();
                if (success) {    
                  final $1 = $$;
                  final $start = startPos1;
                  $$ = new BinaryExpression(BinaryOperator.Plus, emptyString, $1);
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(const [null]);
            }
            if (!success) break;
            seq[3] = $$;
            $$ = _parse_WS();
            if (!success) break;
            seq[4] = $$;
            $$ = _matchString(_strings3, '}}');
            if (!success) break;
            seq[5] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $5 = seq[4];
              final $6 = seq[5];
              final $start = startPos0;
              $$ = $1.length > 0 ? new BinaryExpression(BinaryOperator.Plus, new Literal($1.join()), $4) : $4;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos0;
          if (success) break;
          var startPos2 = _startPos;
          _startPos = _cursor;
          $$ = _parse_TemplateText();
          _startPos = startPos2;
          if (success) break;
          var ch1 = _ch, pos1 = _cursor, startPos3 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_BS();
            if (!success) break;
            var seq = new List(4)..[0] = $$;
            $$ = _matchChar(123, '{');
            if (!success) break;
            seq[1] = $$;
            var ch2 = _ch, pos2 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(123, '{');
            _ch = ch2;
            _cursor = pos2; 
            _testing = testing0;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[2] = $$;
            $$ = _parse_BS();
            if (!success) break;
            seq[3] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $4 = seq[3];
              final $start = startPos3;
              $$ = new Literal($1.join('') + $2[0] + $3.join(''));
            }
            break;
          }
          if (!success) {
            _ch = ch1;
            _cursor = pos1;
          }
          _startPos = startPos3;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_UnaryExpression() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[26] >= pos) {
      $$ = _getFromCache(26);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[26] = pos;
    }  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        while (true) {
          var startPos0 = _startPos;
          _startPos = _cursor;
          $$ = _parse_PostfixExpression();
          _startPos = startPos0;
          if (success) break;
          var ch0 = _ch, pos0 = _cursor, startPos1 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _parse_UnaryOperator();
            if (!success) break;
            var seq = new List(3)..[0] = $$;
            $$ = _parse___();
            if (!success) break;
            seq[1] = $$;
            $$ = _parse_UnaryExpression();
            if (!success) break;
            seq[2] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $3 = seq[2];
              final $start = startPos1;
              
                    if($1 == UpdateOperator.PlusPlus || $1 == UpdateOperator.MinusMinus){
                      return new UpdateExpression($1, $3, true);
                    }
              
                    return new UnaryExpression($1, $3, true);
              
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos1;
          break;
        }
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[26]) {
      _addToCache($$, pos, 26);
    }    
    return $$;
  }
  
  dynamic _parse_UnaryOperator() {
    var $$;
    _token = 4;  
    _tokenStart = _cursor;  
    switch (_getState(_transitions6)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(33, '!');
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = UnaryOperator.Not;
        }
        _startPos = startPos0;
        break;
      case 1:
        while (true) {
          var startPos1 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings8, '++');
          if (success) {    
            final $1 = $$;
            final $start = startPos1;
            $$ = UpdateOperator.PlusPlus;
          }
          _startPos = startPos1;
          if (success) break;
          var ch0 = _ch, pos0 = _cursor, startPos2 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(43, '+');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch1 = _ch, pos1 = _cursor, testing0 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch1;
            _cursor = pos1; 
            _testing = testing0;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos2;
              $$ = UnaryOperator.Plus;
            }
            break;
          }
          if (!success) {
            _ch = ch0;
            _cursor = pos0;
          }
          _startPos = startPos2;
          break;
        }
        break;
      case 2:
        while (true) {
          var startPos3 = _startPos;
          _startPos = _cursor;
          $$ = _matchString(_strings9, '--');
          if (success) {    
            final $1 = $$;
            final $start = startPos3;
            $$ = UpdateOperator.MinusMinus;
          }
          _startPos = startPos3;
          if (success) break;
          var ch2 = _ch, pos2 = _cursor, startPos4 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(45, '-');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch3 = _ch, pos3 = _cursor, testing1 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch3;
            _cursor = pos3; 
            _testing = testing1;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos4;
              $$ = UnaryOperator.Minus;
            }
            break;
          }
          if (!success) {
            _ch = ch2;
            _cursor = pos2;
          }
          _startPos = startPos4;
          break;
        }
        break;
      case 3:
        var startPos5 = _startPos;
        _startPos = _cursor;
        $$ = _matchChar(126, '~');
        if (success) {    
          final $1 = $$;
          final $start = startPos5;
          $$ = UnaryOperator.BitNot;
        }
        _startPos = startPos5;
        break;
      case 4:
        $$ = null;
        success = false;
        break;
      case 5:
        while (true) {
          var ch4 = _ch, pos4 = _cursor, startPos6 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(43, '+');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch5 = _ch, pos5 = _cursor, testing2 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch5;
            _cursor = pos5; 
            _testing = testing2;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos6;
              $$ = UnaryOperator.Plus;
            }
            break;
          }
          if (!success) {
            _ch = ch4;
            _cursor = pos4;
          }
          _startPos = startPos6;
          if (success) break;
          var ch6 = _ch, pos6 = _cursor, startPos7 = _startPos;
          _startPos = _cursor;
          while (true) {  
            $$ = _matchChar(45, '-');
            if (!success) break;
            var seq = new List(2)..[0] = $$;
            var ch7 = _ch, pos7 = _cursor, testing3 = _testing; 
            _testing = _inputLen + 1;
            $$ = _matchChar(61, '=');
            _ch = ch7;
            _cursor = pos7; 
            _testing = testing3;
            $$ = null;
            success = !success;
            if (!success) break;
            seq[1] = $$;
            $$ = seq;
            if (success) {    
              final $1 = seq[0];
              final $2 = seq[1];
              final $start = startPos7;
              $$ = UnaryOperator.Minus;
            }
            break;
          }
          if (!success) {
            _ch = ch6;
            _cursor = pos6;
          }
          _startPos = startPos7;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect10);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse_UnicodeEscapeSequence() {
    var $$;
    switch (_ch == 117 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _matchChar(117, 'u');
          if (!success) break;
          var seq = new List(2)..[0] = $$;
          switch (_getState(_transitions19)) {
            case 0:
              var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
              _startPos = _cursor;
              while (true) {  
                $$ = _parse_HexDigit();
                if (!success) break;
                var seq = new List(4)..[0] = $$;
                $$ = _parse_HexDigit();
                if (!success) break;
                seq[1] = $$;
                $$ = _parse_HexDigit();
                if (!success) break;
                seq[2] = $$;
                $$ = _parse_HexDigit();
                if (!success) break;
                seq[3] = $$;
                $$ = seq;
                break;
              }
              if (!success) {
                _ch = ch1;
                _cursor = pos1;
              }
              _startPos = startPos1;
              break;
            case 1:
            case 2:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            _failure(const [null]);
          }
          if (!success) break;
          seq[1] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $start = startPos0;
            
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
      case 2:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect37);
    }
    return $$;
  }
  
  dynamic _parse_WS() {
    var $$;
    _token = 18;  
    _tokenStart = _cursor;  
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          switch (_getState(_transitions23)) {
            case 0:
              var startPos1 = _startPos;
              _startPos = _cursor;
              $$ = _matchMapping(9, 32, _mapping8);
              _startPos = startPos1;
              break;
            case 1:
              while (true) {
                var startPos2 = _startPos;
                _startPos = _cursor;
                $$ = _matchMapping(9, 32, _mapping8);
                _startPos = startPos2;
                if (success) break;
                var startPos3 = _startPos;
                _startPos = _cursor;
                $$ = _matchString(_strings32, '\r\n');
                _startPos = startPos3;
                break;
              }
              break;
            case 2:
            case 3:
              $$ = null;
              success = false;
              break;
          }
          if (!success && _cursor > _testing) {
            _failure(const [null]);
          }
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = "";
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect39);
    }
    _token = null;
    _tokenStart = null;
    return $$;
  }
  
  dynamic _parse__() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_WS();
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect39);
    }
    return $$;
  }
  
  dynamic _parse___() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_WS();
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect39);
    }
    return $$;
  }
  
  dynamic _parse_propertyAssignment() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[85] >= pos) {
      $$ = _getFromCache(85);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[85] = pos;
    }  
    switch (_getState(_transitions24)) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_propertyName();
          if (!success) break;
          var seq = new List(6)..[0] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[1] = $$;
          $$ = _matchChar(58, ':');
          if (!success) break;
          seq[2] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[3] = $$;
          $$ = _parse_AssignmentExpression();
          if (!success) break;
          seq[4] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[5] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $5 = seq[4];
            final $6 = seq[5];
            final $start = startPos0;
            $$ = [$1, $5];
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[85]) {
      _addToCache($$, pos, 85);
    }    
    return $$;
  }
  
  dynamic _parse_propertyName() {
    var $$;
    switch (_getState(_transitions25)) {
      case 0:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_StringLiteral();
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = $1;
        }
        _startPos = startPos0;
        break;
      case 1:
        var startPos1 = _startPos;
        _startPos = _cursor;
        $$ = _parse_Identifier();
        if (success) {    
          final $1 = $$;
          final $start = startPos1;
          $$ = $1.name;
        }
        _startPos = startPos1;
        break;
      case 2:
        var startPos2 = _startPos;
        _startPos = _cursor;
        $$ = _parse_NumericLiteral();
        if (success) {    
          final $1 = $$;
          final $start = startPos2;
          $$ = $1.toString();
        }
        _startPos = startPos2;
        break;
      case 3:
        $$ = null;
        success = false;
        break;
      case 4:
        while (true) {
          var startPos3 = _startPos;
          _startPos = _cursor;
          $$ = _parse_Identifier();
          if (success) {    
            final $1 = $$;
            final $start = startPos3;
            $$ = $1.name;
          }
          _startPos = startPos3;
          if (success) break;
          var startPos4 = _startPos;
          _startPos = _cursor;
          $$ = _parse_StringLiteral();
          if (success) {    
            final $1 = $$;
            final $start = startPos4;
            $$ = $1;
          }
          _startPos = startPos4;
          if (success) break;
          var startPos5 = _startPos;
          _startPos = _cursor;
          $$ = _parse_NumericLiteral();
          if (success) {    
            final $1 = $$;
            final $start = startPos5;
            $$ = $1.toString();
          }
          _startPos = startPos5;
          break;
        }
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic _parse_propertyNameAndValueList() {
    var $$;          
    var pos = _cursor;             
    if(_cachePos[84] >= pos) {
      $$ = _getFromCache(84);
      if($$ != null) {
        return $$[0];       
      }
    } else {
      _cachePos[84] = pos;
    }  
    switch (_getState(_transitions24)) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_propertyAssignment();
          if (!success) break;
          var seq = new List(3)..[0] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[1] = $$;
          var testing0 = _testing; 
          for (var reps = []; ; ) {
            _testing = _cursor;
            switch (_ch == 44 ? 0 : _ch == -1 ? 2 : 1) {
              case 0:
              case 2:
                var ch1 = _ch, pos1 = _cursor, startPos1 = _startPos;
                _startPos = _cursor;
                while (true) {  
                  $$ = _matchChar(44, ',');
                  if (!success) break;
                  var seq = new List(4)..[0] = $$;
                  $$ = _parse_WS();
                  if (!success) break;
                  seq[1] = $$;
                  $$ = _parse_propertyAssignment();
                  if (!success) break;
                  seq[2] = $$;
                  $$ = _parse_WS();
                  if (!success) break;
                  seq[3] = $$;
                  $$ = seq;
                  if (success) {    
                    final $1 = seq[0];
                    final $2 = seq[1];
                    final $3 = seq[2];
                    final $4 = seq[3];
                    final $start = startPos1;
                    $$ = $3;
                  }
                  break;
                }
                if (!success) {
                  _ch = ch1;
                  _cursor = pos1;
                }
                _startPos = startPos1;
                break;
              case 1:
                $$ = null;
                success = false;
                break;
            }
            if (!success && _cursor > _testing) {
              _failure(_expect1);
            }
            if (success) {  
              reps.add($$);
            } else {
              success = true;
              _testing = testing0;
              $$ = reps;
              break; 
            }
          }
          if (!success) break;
          seq[2] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $start = startPos0;
            $$ = _buildMap($1, $3);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    if (_cacheable[84]) {
      _addToCache($$, pos, 84);
    }    
    return $$;
  }
  
  String _text([int offset = 0]) {
    return new String.fromCharCodes(_input.sublist(_startPos + offset, _cursor));
  }
  
  int _toCodePoint(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      throw new StateError("An empty string contains no elements.");
    }
  
    var start = string.codeUnitAt(0);
    if (length == 1) {
      return start;
    }
  
    if ((start & 0xFC00) == 0xD800) {
      var end = string.codeUnitAt(1);
      if ((end & 0xFC00) == 0xDC00) {
        return (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
      }
    }
  
    return start;
  }
  
  List<int> _toCodePoints(String string) {
    if (string == null) {
      throw new ArgumentError("string: $string");
    }
  
    var length = string.length;
    if (length == 0) {
      return const <int>[];
    }
  
    var codePoints = <int>[];
    codePoints.length = length;
    var i = 0;
    var pos = 0;
    for ( ; i < length; pos++) {
      var start = string.codeUnitAt(i);
      i++;
      if ((start & 0xFC00) == 0xD800 && i < length) {
        var end = string.codeUnitAt(i);
        if ((end & 0xFC00) == 0xDC00) {
          codePoints[pos] = (0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF));
          i++;
        } else {
          codePoints[pos] = start;
        }
      } else {
        codePoints[pos] = start;
      }
    }
  
    codePoints.length = pos;
    return codePoints;
  }
  
  static List<bool> _unmap(List<int> mapping) {
    var length = mapping.length;
    var result = new List<bool>(length * 31);
    var offset = 0;
    for (var i = 0; i < length; i++) {
      var v = mapping[i];
      for (var j = 0; j < 31; j++) {
        result[offset++] = v & (1 << j) == 0 ? false : true;
      }
    }
    return result;
  }
  
  List<ParserError> errors() {
    if (success) {
      return <ParserError>[];
    }
  
    String escape(int c) {
      switch (c) {
        case 10:
          return r"\n";
        case 13:
          return r"\r";
        case 09:
          return r"\t";
        case -1:
          return "";
      }
      return new String.fromCharCode(c);
    } 
    
    String getc(int position) {  
      if (position < _inputLen) {
        return "'${escape(_input[position])}'";      
      }       
      return "end of file";
    }
  
    var errors = <ParserError>[];
    if (_failurePos >= _cursor) {
      var set = new Set<ParserError>();
      set.addAll(_errors);
      for (var error in set) {
        if (error.position >= _failurePos) {
          errors.add(error);
        }
      }
      var names = new Set<String>();  
      names.addAll(_expected);
      if (names.contains(null)) {
        var string = getc(_failurePos);
        var message = "Unexpected $string";
        var error = new ParserError(ParserError.UNEXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      } else {      
        var found = getc(_failurePos);      
        var list = names.toList();
        list.sort();
        var message = "Expected ${list.join(", ")} but found $found";
        var error = new ParserError(ParserError.EXPECTED, _failurePos, _failurePos, message);
        errors.add(error);
      }        
    }
    errors.sort((a, b) => a.position.compareTo(b.position));
    return errors;  
  }
  
  dynamic parse_Start() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_WS();
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          $$ = _parse_Expression();
          if (!success) break;
          seq[1] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[2] = $$;
          $$ = _parse_EOF();
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic parse_Template() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        var testing0 = _testing; 
        for (var reps = []; ; ) {
          _testing = _cursor;
          $$ = _parse_TemplateUnit();
          if (success) {  
            reps.add($$);
          } else {
            success = true;
            _testing = testing0;
            $$ = reps;
            break; 
          }
        }
        if (success) {    
          final $1 = $$;
          final $start = startPos0;
          $$ = _buildTemplateExpress($1);
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = true;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(_expect5);
    }
    return $$;
  }
  
  dynamic parse_expressions() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_WS();
          if (!success) break;
          var seq = new List(4)..[0] = $$;
          $$ = _parse_Expression();
          if (!success) break;
          seq[1] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[2] = $$;
          $$ = _parse_EOF();
          if (!success) break;
          seq[3] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $start = startPos0;
            $$ = $2;
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic parse_forExpression() {
    var $$;
    switch (_ch >= 0 && _ch <= 1114111 ? 0 : _ch == -1 ? 2 : 1) {
      case 0:
      case 2:
        var ch0 = _ch, pos0 = _cursor, startPos0 = _startPos;
        _startPos = _cursor;
        while (true) {  
          $$ = _parse_ForExpressionDecl();
          if (!success) break;
          var seq = new List(5)..[0] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[1] = $$;
          $$ = _matchString(_strings1, 'in');
          if (!success) break;
          seq[2] = $$;
          $$ = _parse_WS();
          if (!success) break;
          seq[3] = $$;
          $$ = _parse_AssignmentExpression();
          if (!success) break;
          seq[4] = $$;
          $$ = seq;
          if (success) {    
            final $1 = seq[0];
            final $2 = seq[1];
            final $3 = seq[2];
            final $4 = seq[3];
            final $5 = seq[4];
            final $start = startPos0;
            $$ = new ForExpression($1["value"], $1["index"], $5);
          }
          break;
        }
        if (!success) {
          _ch = ch0;
          _cursor = pos0;
        }
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  dynamic parse_propertySetParameterList() {
    var $$;
    switch (_getState(_transitions2)) {
      case 0:
      case 2:
        var startPos0 = _startPos;
        _startPos = _cursor;
        $$ = _parse_Identifier();
        _startPos = startPos0;
        break;
      case 1:
        $$ = null;
        success = false;
        break;
    }
    if (!success && _cursor > _testing) {
      _failure(const [null]);
    }
    return $$;
  }
  
  void reset(int pos) {
    if (pos == null) {
      throw new ArgumentError('pos: $pos');
    }
    if (pos < 0 || pos > _inputLen) {
      throw new RangeError('pos');
    }      
    _cursor = pos;
    _cache = new List<Map<int, List>>(91);
    _cachePos = new List<int>.filled(91, -1);  
    _cacheable = new List<bool>.filled(91, false);
    _ch = -1;
    _errors = <ParserError>[];   
    _expected = <String>[];
    _failurePos = -1;
    _startPos = pos;        
    _testing = -1;
    _token = null;
    _tokenStart = null;  
    if (_cursor < _inputLen) {
      _ch = _input[_cursor];
    }
    success = true;    
  }
  
   
    static Expression parse(src){ 
      return (new Parser(src)).parse_Start(); 
    } 
   
    static Expression parseForExpression(src){ 
      return (new Parser(src)).parse_forExpression(); 
    } 
   
    static Expression parseTemplate(src){ 
      return (new Parser(src)).parse_Template(); 
    } 
   
    _lookupIdentify(String name){ 
      print("lookup : " + name); 
      return name; 
    } 
   
   
    _assign(String name, value){ 
      print(name + ":" + value); 
    } 
   
   
    buildLogicalExpression(head, tail) {  
      if(tail.length == 0){  
        return head;  
      }  
   
      var cnt = 0;  
         
      if(tail.length == 1){ 
        return createBinaryExpression(tail[0][1], head, tail[0][3], true); 
      } 
   
      return tail.reduce((result, element) {  
        return createBinaryExpression(element[1], cnt++ == 0 ? createBinaryExpression(tail[0][1], head, tail[0][3], true) : result, element[3], true ); 
      });  
    } 
      
    createBinaryExpression(op, left, right, [logical = false]){  
      return logical ? new LogicalExpression(op, left, right) : new BinaryExpression(op, left, right); 
    }  
   
   
    buildBinaryExpression(head, tail) {  
      if(tail.length == 0){  
        return head;  
      }  
   
      if(tail.length == 1){ 
        return createBinaryExpression(tail[0][1], head, tail[0][3]); 
      } 
   
      var cnt = 0;  
   
      return tail.reduce((result, element) {  
        return createBinaryExpression(element[1], cnt++ == 0 ? createBinaryExpression(tail[0][1], head, tail[0][3]) : result, element[3] ); 
      });  
    }  
   
    _buildList(a, b){ 
        var rtn = <Expression>[a]; 
   
        if(b == null){ 
          return rtn; 
        } 
   
        b.forEach((v)=>rtn.add(v)); 
        return rtn;  
    } 
   
   
    _buildMap(a, b){ 
       
      var rtn = <String, Expression>{}; 
      rtn[a[0]] = a[1]; 
       
      if(b != null){ 
        for(var el in b){ 
          rtn[el[0]] = el[1]; 
        } 
      } 
   
      return rtn; 
    } 
   
    _buildMemberExpression(a, b){ 
   
      var obj = a; 
   
      for(var i in b){ 
        obj = new MemberExpression(obj, i, true); 
      } 
   
      return obj; 
    } 
   
    _buildCall(a, b){ 
      var rtn = new CallExpression(a[0], a[2] == null ? [] : a[2]); 
       
      for(var i in b){ 
   
        if(i[0] != null){ 
          rtn = _buildCall([rtn,"",i[0]], null); 
        }else if(i[1] != null){ 
          rtn = _buildMemberExpression(rtn, [i[1]]); 
        }else if(i[2] != null){ 
          rtn = _buildMemberExpression(rtn, [i[2]]); 
        } 
   
      } 
   
      return rtn; 
    } 
   
    _buildTemplateExpress(list){ 
   
      if(list.length == 1){ 
        return list[0]; 
      } 
   
      var rtn = createBinaryExpression(BinaryOperator.Plus, list[0], list[1]); 
   
      for(var x = 2; x < list.length; x++){ 
        rtn = createBinaryExpression(BinaryOperator.Plus, rtn, list[x]); 
      } 
   
      return rtn; 
    } 
   
    _buildLambda(args, body){ 
      return new LambdaExpression(args, body); 
    } 
   
    static var emptyString = new Literal(""); 
}

class ParserError {
  static const int EXPECTED = 1;    
      
  static const int MALFORMED = 2;    
      
  static const int MISSING = 3;    
      
  static const int UNEXPECTED = 4;    
      
  static const int UNTERMINATED = 5;    
      
  final int hashCode = 0;
  
  final String message;
  
  final int position;
  
  final int start;
  
  final int type;
  
  ParserError(this.type, this.position, this.start, this.message);
  
  bool operator ==(other) {
    if (identical(this, other)) return true;
    if (other is ParserError) {
      return type == other.type && position == other.position &&
      start == other.start && message == other.message;  
    }
    return false;
  }
  
}

